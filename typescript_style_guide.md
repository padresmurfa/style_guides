# TypeScript Coding Style Guide

This document establishes a TypeScript coding style that **prioritizes correctness**, **conformity**, and **readability**. The
intended audience is both human developers and Large Language Models (LLMs) producing or reviewing TypeScript code. Following
these guidelines helps ensure that code generated by humans or AI assistants is predictable, maintainable, and safe to ship.

---

## 1. Guiding Principles
- **Correctness first**: Prefer strict typing, exhaustive handling, and explicitness over brevity. Never sacrifice sound types for
  terseness.
- **Conformity**: Align with the official TypeScript handbook, the ECMAScript standard, and project-specific conventions. Ensure
  code passes all linting, formatting, and type-checking steps before submission.
- **Readability**: Optimize for the next reader. Use descriptive names, consistent structures, and clear control flow.
- **Traceability**: Document reasoning for non-obvious decisions. Include references to specifications or tickets when deviating
  from default patterns.
- **Human + AI collaboration**: Treat LLM output as a draft. Review it manually, enforce this style guide, and run automated checks
  before integrating.

---

## 2. Project Configuration and Tooling
- Enable `"strict": true` (or an equivalent set of strict flags) in `tsconfig.json`.
- Use the latest supported ECMAScript target compatible with deployment environments.
- Prefer `"module": "ESNext"` (or project standard) and rely on build tooling for compatibility.
- Turn on incremental builds (`"incremental": true`) for large projects to improve feedback loops.
- Standardize linting with ESLint (`@typescript-eslint` plugins) and formatting with Prettier or a project-approved formatter.
- Configure CI to run `npm run lint`, `npm run test`, and `tsc --noEmit` (or equivalents) to prevent regressions.
- Document required scripts and tool versions in `package.json` and the project README.

---

## 3. File Organization
- Use a single responsibility per file. If a file exceeds ~300 lines or covers multiple concepts, split it.
- Keep public APIs in `src/` (or equivalent) and tests in mirrored directory structures (e.g., `src/utils/date.ts` ↔
  `tests/utils/date.test.ts`).
- Group related types in `*.types.ts` or colocate them with the module they serve when the scope is narrow.
- Avoid cyclic imports. If encountered, refactor shared types or utilities into a separate module.
- Maintain deterministic module resolution by avoiding barrel files that create ambiguous imports unless the project explicitly
  requires them.

---

## 4. Naming and Formatting
- Use `camelCase` for variables, functions, and object properties; `PascalCase` for classes, interfaces, and type aliases;
  `SCREAMING_SNAKE_CASE` for exported constants.
- Prefix booleans with verbs (`isEnabled`, `hasPermission`, `shouldRetry`).
- For generics, prefer descriptive single letters (`Type`, `Element`, `Props`) over `T` unless constrained by convention.
- Keep line length under 100 characters unless readability significantly improves otherwise.
- Break long import lists into multiple lines alphabetized by symbol name.
- Prefer named exports. Use default exports only when the module exposes a single main entity.
- For JSX, place props on separate lines when exceeding 80 characters, aligning closing tags with the opening tag.

---

## 5. Types and Interfaces
- Default to type aliases for primitives and union compositions; use interfaces for object shapes that benefit from declaration
  merging or class implementation.
- Avoid `any`. When uncertainty exists, use `unknown` and narrow the type explicitly.
- Declare function return types explicitly, especially for public APIs, React components, and exported helpers.
- Use `readonly` for properties that should not change after initialization.
- Prefer discriminated unions for branching logic; include exhaustive `switch`/`if` handling with `never` checks to detect
  missing cases.
- Model `null` and `undefined` precisely. Use optional chaining (`?.`) and nullish coalescing (`??`) judiciously.
- Prefer `Record<Key, Value>` for dynamic mappings instead of `{ [key: string]: Value }`.
- When typing asynchronous operations, always return `Promise<ResolvedType>` and avoid mixing `async`/`await` with `.then`
  chaining in the same block.

---

## 6. Functions and Classes
- Keep functions small and pure when possible. Extract helper functions rather than nesting deeply.
- Order function parameters as `(required, optional, rest)` and prefer a single options object for more than three optional
  parameters.
- Use `const` for function expressions and arrow functions that capture lexical `this`.
- For methods requiring `this`, prefer class fields with arrow functions only when binding is otherwise necessary.
- Seal classes with `private`/`protected` modifiers to communicate intent. Avoid exposing internal state.
- Implement interfaces or abstract classes when multiple implementations are expected; document differences clearly.
- Ensure constructors perform minimal work—delegate heavy lifting to initialization methods.

---

## 7. Control Flow and Error Handling
- Treat `try/catch` blocks as a last resort. Prefer returning `Result`-style objects or `Either` patterns when appropriate.
- When catching errors, narrow the type (e.g., `if (error instanceof SomeError)`) before accessing properties.
- Never swallow errors silently. Log with context or rethrow using `throw new Error("message", { cause: error })` where available.
- Use early returns to reduce nested conditionals.
- Favor `for...of` loops over `.forEach` when using `await` or `continue`/`break`.
- Avoid implicit conversions. Use strict equality (`===`) and explicit parsing (`Number(value)`, `Boolean(value)`).

---

## 8. Data Structures and Immutability
- Treat objects and arrays as immutable by default. Use spread syntax or helper functions to create new instances rather than
  mutating in place.
- When immutability is impossible (e.g., performance-critical sections), encapsulate mutation within a small, well-documented
  module.
- Prefer `Map`/`Set` for dynamic key lookups and membership tests over object literals when keys are not fixed strings.
- Document performance expectations and complexity assumptions for custom data structures.

---

## 9. Documentation and Comments
- Use TSDoc-style comments (`/** ... */`) for exported functions, classes, and complex types. Include parameter, return, and
  error information.
- Write narrative comments for non-trivial algorithms or domain-specific logic. Explain the “why,” not the “what.”
- Keep comments up-to-date; outdated documentation is worse than no documentation.
- For LLM-generated code, include a short comment noting the source and human reviewer if required by project policy.

---

## 10. Testing and Verification
- Write unit tests for all exported functions and classes. Aim for meaningful coverage rather than raw percentages.
- Prefer deterministic tests. Use fixed seeds for randomness and mock dates/times when needed.
- Mirror the production module structure in the test suite for discoverability.
- Use TypeScript for tests (`*.test.ts`) to enforce typing in test code.
- Include integration or end-to-end tests for modules interacting with external systems.
- Run `tsc`, linters, and tests before committing. Document the command sequence in PR descriptions when the tooling is not
  automated.

---

## 11. Working with Frameworks and Libraries
- Follow the framework’s official style guides (e.g., Angular Style Guide, React hooks rules) in addition to this document.
- Keep framework-specific types in dedicated modules (e.g., `react-app-env.d.ts`).
- Avoid importing from deep internal paths of dependencies; rely on public APIs.
- Encapsulate third-party integrations behind adapters or services with narrow, well-typed interfaces.

---

## 12. Concurrency and Asynchronous Patterns
- Always handle promise rejections. Use `void someAsyncCall().catch(...)` only when deliberate and accompanied by a comment.
- Use `Promise.all` / `Promise.allSettled` for parallel work, but guard against large arrays causing resource exhaustion.
- Cancel async work when components unmount or when newer operations supersede older ones (e.g., using `AbortController`).
- Avoid leaking timers or intervals; store references and clear them in lifecycle hooks or cleanup callbacks.

---

## 13. Security and Reliability
- Treat user input as untrusted. Validate and sanitize before use.
- Enable ESLint rules such as `@typescript-eslint/no-floating-promises`, `no-implied-eval`, and security-focused plugins when
  applicable.
- Avoid string concatenation for building HTML, SQL, or command strings—use template functions or parameterized queries.
- Handle `fetch`/HTTP errors explicitly, checking both network errors and non-2xx status codes.

---

## 14. AI and LLM-Specific Guidance
- **Never** accept generated code without review. Verify adherence to this style guide and project requirements.
- Prompt LLMs with explicit instructions from this document (e.g., “Return types must be explicit”).
- Compare generated solutions against official TypeScript documentation and trusted sources.
- Watch for hallucinated imports or APIs. Cross-check with TypeScript’s standard library and project dependencies.
- Enforce deterministic formatting via automated tools; do not rely on LLM whitespace or import organization.
- Capture reasoning. When an LLM suggests non-obvious logic, document the rationale in comments or PR discussions.

---

## 15. Pull Requests and Code Reviews
- Include a summary of changes, testing steps, and any deviations from this guide in the PR description.
- Request reviews from subject-matter experts for complex domains.
- Use code review checklists covering types, error handling, and tests. Verify that code remains maintainable and clear.
- Reject code that fails type checks, lacks tests, or violates readability expectations—even if it “works.”

---

## 16. Continuous Improvement
- Revisit this guide periodically to align with the evolving TypeScript ecosystem.
- Encourage contributors to propose updates when encountering ambiguous or outdated rules.
- Record team decisions in a changelog section or architecture decision records (ADRs) for transparency.

By following this guide, teams and AI assistants can produce TypeScript code that is robust, consistent, and easy to maintain.
