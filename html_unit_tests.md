# HTML Unit Testing Style Guide

This document adapts the structure and intent of the **C# Unit Testing Style Guide** to focus specifically on validating
**HTML markup, templates, and component rendering**. It defines best practices for writing **clear, maintainable, and
accessibility-aware** unit tests that run in DOM-enabled JavaScript test runners such as **Jest + Testing Library**,
**Vitest**, or **Mocha + jsdom**.

---

## **Target Audience**

The guide is designed for front-end developers and Large Language Models (LLMs) acting as coding assistants. Following
these conventions keeps HTML-focused unit tests **readable, deterministic, and aligned with accessibility standards**.

The rules lean toward automation. Human authors may relax them where appropriate, but **tests generated by LLMs must
adhere to every requirement unless an inline comment explicitly documents a justified deviation**.

---

## **1. Test Directory and File Organization**

Predictable file placement makes it easy to discover tests that cover a particular template or component.

- Mirror the production folder structure under a dedicated `__tests__`, `tests`, or `*.test` directory hierarchy. For
  example `components/product-card.html` is paired with `components/__tests__/product-card.test.ts` (or `.js`).
- Co-locate tests with the HTML source when possible; otherwise maintain a one-to-one path mapping between `src/` and
  `tests/`.
- Avoid aggregating unrelated HTML fixtures inside a single test file. **One test file must own a single template or
  component**.
- Test filenames must end with `.test.js`, `.test.ts`, `.spec.js`, or `.spec.ts` depending on the project standard, and
  the basename should match the HTML file exactly (e.g. `product-card.html` ‚Üí `product-card.test.ts`).

‚úÖ **Good Example:**
```text
components/
‚îú‚îÄ‚îÄ product-card.html
‚îî‚îÄ‚îÄ __tests__/
    ‚îî‚îÄ‚îÄ product-card.test.ts
```

üö´ **Bad Example:**
```text
components/
‚îú‚îÄ‚îÄ product-card.html
‚îî‚îÄ‚îÄ tests/
    ‚îî‚îÄ‚îÄ commerce-layout.test.ts   // ‚ùå File name does not match subject under test
```

---

## **2. Test Suite and Describe Block Naming**

Consistent `describe` blocks make the relationship between tests and HTML artifacts obvious to reviewers.

- The top-level `describe` must mirror the HTML filename (without extension) and append ` markup` (e.g.
  `describe('product-card markup', ...)`).
- Nested `describe` blocks segment scenarios such as **states**, **variants**, or **interaction modes**. Avoid combining
  multiple HTML files under one suite.
- Each `describe` block should include a short comment explaining the HTML fragment or scenario being tested.

‚úÖ **Good Example:**
```ts
// Covers the default product card fragment
describe('product-card markup', () => {
  // ...
});
```

üö´ **Bad Example:**
```ts
describe('rendering tests', () => { /* ‚ùå Too generic */ });
```

---

## **3. Test Case Naming**

Readable test names clarify what portion of the DOM is being verified and why.

- Use `it('renders ...')` or `test('renders ...')` with natural-language descriptions.
- Start names with an action (`renders`, `announces`, `applies`, `matches`, etc.) followed by the condition and expected
  result (`renders "Sale" badge when product is discounted`).
- Avoid vague verbs like "works" or "handles".
- Do not duplicate component names already expressed in the containing `describe` block unless it improves clarity.

‚úÖ **Good Example:**
```ts
it('renders the price with currency formatting', () => {
  // ...
});
```

üö´ **Bad Example:**
```ts
test('price output', () => { /* ‚ùå Missing behavior statement */ });
```

---

## **4. Standard Test Sections**

Port the C# GIVEN/WHEN/THEN discipline into JavaScript tests using **section comments**. Each test must follow the
ordered sections below unless a section is irrelevant, in which case omit it entirely.

1. **GIVEN**
   - Declare fixtures and initial props with variables prefixed `given` (e.g. `const givenProduct = ...`).
   - HTML snippets used across tests should come from fixture builders (see Section 7).
   - The GIVEN block must not be merged with other sections.

2. **MOCKING**
   - Create stubbed browser APIs (`mockIntersectionObserver`, `mockMatchMedia`, etc.) or network mocks here.
   - Prefix mock variables with `mock` and reset them in `afterEach` if global state is mutated.
   - Only include when the test depends on mocked collaborators; otherwise omit.

3. **SETUP**
   - Render the component or template using testing utilities (`render`, `document.body.innerHTML = ...`).
   - Assign DOM references to variables prefixed `env` to mirror dependency injection (e.g. `const envContainer = render(...)`).

4. **SYSTEM UNDER TEST**
   - Capture the element under scrutiny in a `sut` variable (`const sut = envContainer.getByRole('button', { name: /buy/i });`).
   - Never mix query logic with assertions‚Äîstore the element once here.

5. **WHEN**
   - Perform user interactions (`await user.click(...)`) or call rendering helpers that trigger DOM updates.
   - Store outcomes in variables prefixed `actual`.

6. **EXPECTATIONS**
   - Define expected text, attributes, or class lists in variables prefixed `expected`.

7. **THEN**
   - Assert DOM state using Testing Library queries or DOM APIs, comparing `actual*` to `expected*`.
   - Prefer semantic queries (`getByRole`, `getByLabelText`) over brittle selectors.

8. **ACCESSIBILITY** (optional but encouraged)
   - Run accessibility assertions (`await expect(sut).toHaveNoViolations()`, `expect(sut).toHaveAccessibleName(...)`).

9. **BEHAVIOR**
   - Verify mock interactions (`expect(mockAnalytics).toHaveBeenCalledWith(...)`). This section is required if the test
     uses mocks.

Separate each section with a full-sentence comment (e.g. `// GIVEN: a discounted product`).

---

## **5. DOM Query Practices**

Reliable queries ensure tests stay resilient as markup evolves.

- Favor **role-, label-, and text-based queries** from Testing Library before resorting to `querySelector`.
- When verifying structure, prefer `within(sut).getByText(...)` to limit scope.
- Avoid snapshot testing for entire documents; instead assert on meaningful fragments.
- If a query relies on CSS classes, document why semantic selectors are insufficient.

---

## **6. Assertion Conventions**

- Always compare using `expected*` and `actual*` variables introduced in the EXPECTATIONS and WHEN sections.
- Use matcher helpers from Testing Library (`toHaveTextContent`, `toHaveAttribute`, `toBeVisible`) to express intent.
- Assertions must target one behavior per test. If multiple aspects need verification, split into separate `it` blocks.
- Never assert against raw literals inline‚Äîassign them to `expected` variables first.

‚úÖ **Good Example:**
```ts
// EXPECTATIONS: the CTA text indicates urgency
const expectedCtaLabel = 'Buy now';

// THEN: the button includes the expected accessible name
expect(actualButton).toHaveAccessibleName(expectedCtaLabel);
```

üö´ **Bad Example:**
```ts
expect(button.textContent).toBe('Buy now'); // ‚ùå Inline literal and brittle query
```

---

## **7. Fixture Builders**

Reusable fixtures help keep HTML tests expressive while avoiding duplication.

- Store shared HTML snippets in factory functions such as `buildProductHtml(overrides)` or template literals tagged with
  helper functions.
- Name factory functions with a `create` or `build` prefix and export them from a `fixtures` module adjacent to the tests.
- Prefer semantic data defaults (realistic product names, accessible labels) over placeholder strings.
- When a fixture evolves, update all dependent tests in tandem to preserve alignment with real templates.

‚úÖ **Good Example:**
```ts
export function createProductFixture(overrides: Partial<Product> = {}): Product {
  return {
    id: 'sku-123',
    name: 'Eco Bottle',
    price: '$19.99',
    badge: null,
    ...overrides,
  };
}
```

---

## **8. Handling Browser APIs and Globals**

HTML unit tests frequently interact with browser-specific behavior. Keep them deterministic.

- Stub globals (e.g. `window.matchMedia`) in the MOCKING section and restore them in `afterEach`.
- Use `jest.spyOn` or equivalent to monitor functions and verify calls in the BEHAVIOR section.
- When testing layout-affecting attributes, rely on computed styles or classes rather than actual layout measurement unless
  the logic depends on it.
- Document any deviations from jsdom defaults (e.g. manual `ResizeObserver` polyfills) with comments referencing the requirement.

---

## **9. Accessibility and Semantic Checks**

HTML unit tests must enforce accessibility expectations whenever feasible.

- Include `ACCESSIBILITY` sections verifying ARIA roles, accessible names, `aria-` attributes, and keyboard focus order.
- Use tools like `@testing-library/jest-dom` and `jest-axe` to assert that rendered markup passes accessibility rules.
- Ensure form inputs have associated labels and meaningful placeholder text.
- When bypassing accessibility checks (e.g. because the markup is intentionally hidden), add an inline comment documenting why.

---

## **10. Event and Interaction Testing**

- Use `@testing-library/user-event` (or equivalent) for realistic event dispatch. Avoid calling DOM methods like
  `element.click()` unless simulating low-level behavior.
- Capture side effects in the WHEN section (`const actualCustomEvent = await waitFor(...)`).
- Prefer awaiting asynchronous interactions rather than relying on timers. When timers are required, use fake timers and
  reset them after the test.

---

## **11. Managing Snapshots**

Snapshot tests often become brittle for HTML.

- Limit snapshots to tiny, stable fragments (e.g. a generated `meta` tag) and store them inline with
  `` expect(actualMeta).toMatchInlineSnapshot(...) ``.
- Document why a snapshot is necessary; otherwise favor explicit assertions on structure, attributes, and text.
- When updating a snapshot, review the diff carefully and add comments describing the behavioral change it represents.

---

## **12. Copy-Paste vs. Helpers**

As with the C# guide, duplication is acceptable when it keeps tests readable.

- Prefer copying the GIVEN/SETUP scaffolding from a canonical "happy path" test and adjusting values over introducing
  opaque helper functions.
- Introduce shared helpers only when they make the test easier to read than the duplicated code they replace.
- If a helper exists, place it next to the tests and document the scenarios it supports.

---

## **13. Determinism and Time-Based Behavior**

- Replace direct calls to `Date.now()`, `performance.now()`, or random generators with injected utilities that tests can
  control. Store them in `env` variables.
- When markup varies based on locale or timezone, freeze the locale by setting `Intl.DateTimeFormat` mocks in the MOCKING
  section.
- Ensure tests reset global state (`document.body.innerHTML`, cookies, local storage) in `afterEach` hooks.

---

## **14. Documentation and Comments**

- Every test suite (`describe`) and test case must include a concise comment summarizing the behavior it covers.
- Section comments must be full sentences describing the intent (`// EXPECTATIONS: the banner announces the sale dates`).
- When deviating from any rule in this guide, add an inline comment explaining the exception and link to an issue if relevant.

---

## **15. Breaking the Rules**

These guidelines are intentionally prescriptive. Deviate only when the standard structure would obscure intent.

- Any deviation must increase clarity or determinism for the specific scenario.
- Document the rationale inline so future maintainers understand why the exception exists.
- Revisit exceptions regularly as templates evolve to restore the standard structure when possible.

